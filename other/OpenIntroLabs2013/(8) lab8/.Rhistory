indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = cbbPalette[i]
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i-1
}
plot(model$model[,1] ~ model$model[,num_pred], col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
legend("bottomright", col = cbbPalette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]))
for(j in 1:nLines){
abline(intercepts[j], slope, col = cbbPalette[j], lwd = 2, ...)
}
}
multiLines(m_bty_gen)
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = cbbPalette[i]
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i-1
}
plot(model$model[,1] ~ model$model[,num_pred], col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = cbbPalette[j], lwd = 2, ...)
}
legend("bottomright", col = cbbPalette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
slope
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = cbbPalette[i]
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i-1
}
plot(model$model[,1] ~ model$model[,num_pred], col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = cbbPalette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = cbbPalette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
palette <- c("#56B4E9", "#CC79A7", "#009E73", "#E69F00", "#F0E442", "#0072B2", "#D55E00")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = palette[i]
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i-1
}
plot(model$model[,1] ~ model$model[,num_pred], col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = palette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = palette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
palette <- c("#56B4E9", "#009E73", "#CC79A7", "#E69F00", "#F0E442", "#0072B2", "#D55E00")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = palette[i]
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i-1
}
plot(model$model[,1] ~ model$model[,num_pred], col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = palette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = palette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
palette <- c("#E69F00", "#56B4E9", "#D55E00", "#009E73", "#CC79A7", "#F0E442", "#0072B2", )
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = palette[i]
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i-1
}
plot(model$model[,1] ~ model$model[,num_pred], col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = palette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = palette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
palette <- c("#E69F00", "#56B4E9", "#D55E00", "#009E73", "#CC79A7", "#F0E442", "#0072B2")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = palette[i]
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i-1
}
plot(model$model[,1] ~ model$model[,num_pred], col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = palette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = palette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
palette <- c("#E69F00", "#56B4E9", "#D55E00", "#009E73", "#CC79A7", "#F0E442", "#0072B2")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = palette[i]
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i
}
plot(model$model[,1] ~ model$model[,num_pred], col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = palette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = palette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
palette <- c("#E69F00", "#56B4E9", "#D55E00", "#009E73", "#CC79A7", "#F0E442", "#0072B2")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = palette[i]
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i
}
plot(model$model[,1] ~ jitter(model$model[,num_pred]), col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = palette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = palette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
palette <- c("#E69F00", "#56B4E9", "#D55E00", "#009E73", "#CC79A7", "#F0E442", "#0072B2")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = adjustcolor(palette[i],0.80)
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i+14
}
plot(model$model[,1] ~ jitter(model$model[,num_pred]), col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = palette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = palette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
palette <- c("#E69F00", "#56B4E9", "#D55E00", "#009E73", "#CC79A7", "#F0E442", "#0072B2")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = adjustcolor(palette[i],0.40)
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i+14
}
plot(model$model[,1] ~ jitter(model$model[,num_pred]), col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = palette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = palette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
multiLines(m_bty_gen)
?save
evals <- read.csv("evals.csv")
multiLines <- function(model, ...){
if(class(model)!="lm"){
warning("Model must be the output of the function lm()")
}
if(length(model$xlevels)!=1){
warning("Model must contain exactly one categorical predictor")
}
if(length(model$coef)-length(model$xlevels[[1]])!=1){
warning("Model must contain exactly one non-categorical predictor")
}
palette <- c("#E69F00", "#56B4E9", "#D55E00", "#009E73", "#CC79A7", "#F0E442", "#0072B2")
baseIntercept <- model$coef[1]
nLines <- length(model$xlevels[[1]])
intercepts <- c(baseIntercept, rep(0, nLines-1))
indicatorInd <- c(1, rep(0, nLines)) # used to find slope parameter by process of elimination
for(i in 1:(nLines-1)){
indicatorName <- paste(names(model$contrasts),model$xlevels[[1]][1+i], sep = "")
intercepts[i+1] <- baseIntercept + model$coef[names(model$coef)==indicatorName]
indicatorInd <- indicatorInd + (names(model$coef)==indicatorName)
}
slope <- model$coef[!indicatorInd]
num_pred = which(names(model$model[,-1]) != names(model$xlevels)) + 1
cat_pred = which(names(model$model[,-1]) == names(model$xlevels)) + 1
model$model$COL = NA
model$model$PCH = NA
for(i in 1:nLines){
model$model$COL[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = adjustcolor(palette[i],0.40)
model$model$PCH[model$model[,cat_pred] == levels(model$model[,cat_pred])[i]] = i+14
}
plot(model$model[,1] ~ jitter(model$model[,num_pred]), col = model$model$COL, pch = model$model$PCH,
ylab = names(model$model)[1],
xlab = names(model$model)[num_pred])
for(j in 1:nLines){
abline(intercepts[j], slope, col = palette[j], lwd = 2, ...)
}
if(slope > 0){legend_pos = "bottomright"}
if(slope < 0){legend_pos = "topleft"}
legend(legend_pos, col = palette[1:nLines], lty = 1, legend = levels(model$model[,cat_pred]), lwd = 2)
}
save(evals, multiLines, file="evals.RData")
load("~/Dropbox/OI Labs/(8) lab8 - in progress/evals.RData")
rm(ls=list())
rm(ls())
rm(list-ls())
load("~/Dropbox/OI Labs/(8) lab8 - in progress/evals.RData")
plot(evals$score ~ evals$bty_avg)
plot(evals$bty_avg ~ evals$bty_f1lower)
cor(evals$bty_avg, evals$bty_f1lower)
m_bty_gen <- lm(score ~ bty_avg + gender, data = evals)
summary(m_bty_gen)
multiLines(m_bty_gen)
m_full <- lm(score ~ rank + ethnicity + gender + language + age + cls_perc_eval
+ cls_students + cls_level + cls_profs + cls_credits + bty_avg
+ pic_outfit + pic_color, data = evals)
summary(m_full)
install.packages("parser")
?
knit_theme
??
knit_theme
install.packages("knitr")
library(knitr)
knit_theme$get(theme)
knit_theme$get
knit_theme
?knit_theme
knit_theme$get()
eclipse_theme()
knit_theme(acid)
knit_theme$get(acid)
knit_theme$get("cid")
knit_theme$get("acid")
knit_theme$get("acid")
thm = knit_theme$get("acid"
)
library(knitr)
thm = knit_theme$get("acid")
thm = knit_theme$get("print")
opts_knit$set(out.format = "latex")
thm = knit_theme$get("print")
fix(thm)
fix(thm)
fix(thm)
fix(thm)
knit_theme$get()
install.packages("highlight")
library(highlight)
